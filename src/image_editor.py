# image_editor.py
from typing import List
import torch

from utils import (
    create_mask,
    generate_random_samples,
    synthesize_residual,
    masking,
)
from attr_func_registry import attr_func_registry


class ImageEditor:
    def __init__(self, model, net, preprocess, dilation, attr_func_name, seed=None):
        self.model = model
        self.net = net
        self.preprocess = preprocess
        self.dilation = dilation
        self.attr_func_strategy = attr_func_registry.get(attr_func_name)

        if seed is not None:
            torch.manual_seed(seed)

    def segment_image(self, image) -> torch.Tensor:
        t_image = self.preprocess.process(image)
        out = self.net(t_image)[0]

        return out.squeeze(0).argmax(0)

    def synthesize_image(
        self,
        input_image,
        eta,
        variance_noises: List = [],
        mask=None,
        residuals_o=None,
        attr_func_kwargs=None,
    ):
        residuals = list()

        for step_idx, step_time in enumerate(self.model.scheduler.timesteps):
            residual = synthesize_residual(
                self.model, input_image, step_idx, step_time, mask, residuals_o
            )

            if eta > 0:
                variance_noise = variance_noises[step_idx]
            else:
                # if none, variance_noise is generated by the model in the step method
                variance_noise = None

            # if an attr_func like 'make_blue', apply it here
            if self.attr_func_strategy and attr_func_kwargs is not None:
                input_image = self.attr_func_strategy.apply(
                    input_image,
                    residual,
                    step_time,
                    model=self.model,
                    mask=mask,  # pass the mask to the stragegy
                    **attr_func_kwargs,
                )

            input_image = self.model.scheduler.step(
                residual, step_time, input_image, eta=eta, variance_noise=variance_noise
            ).prev_sample

            residuals.append(residual)

        return input_image, residuals

    def edit_image(
        self,
        classes,
        eta,
        dilation=False,
        attr_func_kwargs=None,
    ):
        x_t = generate_random_samples(1, self.model)
        x_tv = generate_random_samples(1, self.model)

        zso = generate_random_samples(
            self.model.scheduler.num_inference_steps, self.model
        )
        zsv = generate_random_samples(
            self.model.scheduler.num_inference_steps, self.model
        )

        image_o, residuals_o = self.synthesize_image(x_t, eta=eta, variance_noises=zso)
        image_v, residuals_v = self.synthesize_image(x_tv, eta=eta, variance_noises=zsv)
        parsing_o = self.segment_image(image_o)
        parsing_v = self.segment_image(image_v)
        mask_o = create_mask(
            parsing_o,
            classes=classes,
            dilation=dilation,
            preprocess=self.preprocess,
            dilation2d=self.dilation,
        )
        mask_v = create_mask(
            parsing_v,
            classes=classes,
            dilation=dilation,
            preprocess=self.preprocess,
            dilation2d=self.dilation,
        )
        x_t_edit = masking(mask_o, x_t, x_tv)
        zs = [masking(mask_o, zo, zv) for zo, zv in zip(zso, zsv)]

        image_edit, residuals_edit = self.synthesize_image(
            x_t_edit,
            eta=eta,
            variance_noises=zs,
            mask=mask_o,
            residuals_o=residuals_o,
            attr_func_kwargs=attr_func_kwargs,
        )

        return (
            image_o,
            image_v,
            image_edit,
            parsing_o.cpu(),
            parsing_v.cpu(),
            mask_o.permute(0, 2, 3, 1).squeeze().cpu(),
            mask_v.permute(0, 2, 3, 1).squeeze().cpu(),
            residuals_o,
            residuals_v,
            residuals_edit,
        )
