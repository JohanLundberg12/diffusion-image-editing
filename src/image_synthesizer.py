from typing import List, Optional, Union
import torch
from diffusers import DDIMPipeline  # type: ignore

from attr_func_strategy import AttrFuncStrategy
from mask_handler import MaskHandler


class ImageSynthesizer:
    def __init__(self, model):
        self.model = model
        self.mask_handler: Optional[MaskHandler] = None

    def synthesize_residual(
        self,
        model: DDIMPipeline,
        input_image: torch.Tensor,
        step_idx: int,
        step_time: int,
        residuals: Optional[List] = [],
    ):
        with torch.no_grad():
            residual = model.unet(input_image, step_time).sample  # type: ignore

            if self.mask_handler and self.mask_handler.mask and residuals:
                residual = self.mask_handler.apply_mask(
                    self.mask_handler.mask, residuals[step_idx], residual
                )

        return residual

    def synthesize_image(
        self,
        x_t: torch.Tensor,
        zs: Optional[List] = [],
        eta: float = 0,
        residuals: Optional[List] = [],
        strategy: Optional[AttrFuncStrategy] = None,
    ) -> Union[torch.Tensor, List[torch.Tensor]]:
        new_residuals = list()

        for step_idx, step_time in enumerate(self.model.scheduler.timesteps):
            residual = self.synthesize_residual(
                self.model, x_t, step_idx, step_time, residuals
            )

            if eta > 0 and zs:
                variance_noise = zs[step_idx]
            else:
                # if none, variance_noise is generated by the model in the step method
                variance_noise = None

            # nudge the latent variable x_t using the strategy
            if strategy:
                x_t = strategy.apply(
                    x_t,
                    residual,
                    step_time,
                    model=self.model,
                )

            x_t = self.model.scheduler.step(
                residual, step_time, x_t, eta=eta, variance_noise=variance_noise
            ).prev_sample

            new_residuals.append(residual)

        return x_t, new_residuals
